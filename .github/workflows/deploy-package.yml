name: Deploy Package

on:
  workflow_dispatch:
    inputs:
      package_name:
        description: Nombre del package a promover
        required: true
      plan:
        description: Plan de promoción (desde dev)
        type: choice
        options: [dev-to-qa, dev-qa-prod]
        default: dev-to-qa
      dry_run:
        description: Ejecutar promoción en modo dry-run
        type: choice
        options: ['false', 'true']
        default: 'false'

permissions:
  contents: write
  issues: write

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Validar inputs y variables
        run: |
          echo "package_name=${{ inputs.package_name }}"
          echo "plan=${{ inputs.plan }}"
          if [ -z "${{ vars.APP_UUID }}" ]; then
            echo "❌ Falta la variable de repositorio APP_UUID. Defínela en Settings > Secrets and variables > Variables." >&2
            exit 1
          fi

  export:
    needs: validate
    uses: vrgroup-lab/appian-cicd-core/.github/workflows/export.yml@icfbuild
    secrets: inherit
    with:
      env: dev
      deploy_kind: package
      app_uuid: ${{ vars.APP_UUID }}
      package_name: ${{ inputs.package_name }}
      dry_run: false

  archive_export:
    name: Guardar artefactos de export
    needs: export
    runs-on: ubuntu-latest
    outputs:
      artifact_dir: ${{ steps.publish.outputs.artifact_dir }}
      metadata_path: ${{ steps.publish.outputs.metadata_path }}
      icf_template_path: ${{ steps.locate_template.outputs.icf_template_path }}
    steps:
      - name: Checkout sandbox
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Preparar carpeta destino
        id: prep
        env:
          EXPORT_ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}
        run: |
          set -euo pipefail
          name="${EXPORT_ARTIFACT_NAME}"
          if [ -z "$name" ]; then
            name="export-${GITHUB_RUN_ID}"
          fi
          dest="appian-artifacts/$name"
          mkdir -p "$dest"
          echo "dest=$dest" >> "$GITHUB_OUTPUT"

      - name: Descargar paquete principal
        if: ${{ needs.export.outputs.artifact_name != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.export.outputs.artifact_name }}
          path: ${{ steps.prep.outputs.dest }}

      - name: Descargar scripts de base de datos
        if: ${{ needs.export.outputs.database_scripts != '' && needs.export.outputs.database_scripts != '[]' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ format('{0}-db-scripts', needs.export.outputs.artifact_name) }}
          path: ${{ steps.prep.outputs.dest }}/database-scripts

      - name: Descargar archivo de customización
        if: ${{ needs.export.outputs.customization_file != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ format('{0}-customization', needs.export.outputs.artifact_name) }}
          path: ${{ steps.prep.outputs.dest }}/customization

      - name: Descargar template de customización
        if: ${{ needs.export.outputs.customization_template != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ format('{0}-customization-template', needs.export.outputs.artifact_name) }}
          path: ${{ steps.prep.outputs.dest }}/customization-template

      - name: Descargar plugins
        if: ${{ needs.export.outputs.plugins_zip != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ format('{0}-plugins', needs.export.outputs.artifact_name) }}
          path: ${{ steps.prep.outputs.dest }}/plugins

      - name: Registrar metadata de export
        env:
          DEST: ${{ steps.prep.outputs.dest }}
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}
          ARTIFACT_PATH: ${{ needs.export.outputs.artifact_path }}
          ARTIFACT_DIR: ${{ needs.export.outputs.artifact_dir }}
          DATABASE_SCRIPTS: ${{ needs.export.outputs.database_scripts }}
          PLUGINS_ZIP: ${{ needs.export.outputs.plugins_zip }}
          CUSTOMIZATION_FILE: ${{ needs.export.outputs.customization_file }}
          CUSTOMIZATION_TEMPLATE: ${{ needs.export.outputs.customization_template }}
          DOWNLOADED_FILES: ${{ needs.export.outputs.downloaded_files }}
          DEPLOYMENT_UUID: ${{ needs.export.outputs.deployment_uuid }}
          DEPLOYMENT_STATUS: ${{ needs.export.outputs.deployment_status }}
        run: |
          set -euo pipefail
          dest="${DEST}/export-metadata.json"
          db_json="${DATABASE_SCRIPTS}"
          if [[ -z "$db_json" ]]; then
            db_json='[]'
          elif ! echo "$db_json" | jq empty >/dev/null 2>&1; then
            db_json='[]'
          fi
          files_json="${DOWNLOADED_FILES}"
          if [[ -z "$files_json" ]]; then
            files_json='[]'
          elif ! echo "$files_json" | jq empty >/dev/null 2>&1; then
            files_json='[]'
          fi
          mkdir -p "${DEST}"
          jq -n \
            --arg artifact_name "$ARTIFACT_NAME" \
            --arg artifact_path "$ARTIFACT_PATH" \
            --arg artifact_dir "$ARTIFACT_DIR" \
            --arg plugins_zip "$PLUGINS_ZIP" \
            --arg customization_file "$CUSTOMIZATION_FILE" \
            --arg customization_template "$CUSTOMIZATION_TEMPLATE" \
            --arg deployment_uuid "$DEPLOYMENT_UUID" \
            --arg deployment_status "$DEPLOYMENT_STATUS" \
            --argjson database_scripts "$db_json" \
            --argjson downloaded_files "$files_json" \
            '{
              artifact_name: $artifact_name,
              artifact_path: $artifact_path,
              artifact_dir: $artifact_dir,
              database_scripts: $database_scripts,
              plugins_zip: $plugins_zip,
              customization_file: $customization_file,
              customization_template: $customization_template,
              downloaded_files: $downloaded_files,
              deployment_uuid: $deployment_uuid,
              deployment_status: $deployment_status
            }' > "$dest"

      - name: Localizar plantilla ICF
        id: locate_template
        env:
          DEST: ${{ steps.prep.outputs.dest }}
        run: |
          set -euo pipefail
          dest="${DEST}"
          path=""
          if [ -d "${dest}/customization-template" ]; then
            path="$(find "${dest}/customization-template" -type f -name '*.properties' -print -quit)"
          fi
          if [ -z "$path" ] && [ -d "${dest}/customization" ]; then
            path="$(find "${dest}/customization" -type f -name '*.properties' -print -quit)"
          fi
          if [ -z "$path" ]; then
            path="$(find "${dest}" -maxdepth 1 -type f -name '*.properties' -print -quit || true)"
          fi
          if [ -n "$path" ]; then
            path="$(realpath "$path")"
          fi
          echo "icf_template_path=${path}" >> "$GITHUB_OUTPUT"

      - name: Publicar rutas generadas
        id: publish
        env:
          DEST: ${{ steps.prep.outputs.dest }}
          ICF_TEMPLATE_PATH: ${{ steps.locate_template.outputs.icf_template_path }}
        run: |
          set -euo pipefail
          echo "artifact_dir=${DEST}" >> "$GITHUB_OUTPUT"
          echo "metadata_path=${DEST}/export-metadata.json" >> "$GITHUB_OUTPUT"
          if [ -n "${ICF_TEMPLATE_PATH}" ]; then
            echo "icf_template_path=${ICF_TEMPLATE_PATH}" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit artefactos
        env:
          DEST: ${{ steps.prep.outputs.dest }}
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}
        run: |
          set -euo pipefail
          git status --short
          git add "$DEST"
          if git diff --cached --quiet; then
            echo "Sin cambios que versionar"
            exit 0
          fi
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git commit -m "chore: almacenar artefacto $ARTIFACT_NAME"
          git push

      - name: Mostrar detalles del deployment
        run: |
          echo "deployment_uuid=${{ needs.export.outputs.deployment_uuid }}"
          echo "deployment_status=${{ needs.export.outputs.deployment_status }}"

  icf_guidance:
    name: Registrar instrucciones ICF
    needs: archive_export
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.raise.outputs.issue_number }}
      issue_url: ${{ steps.raise.outputs.issue_url }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Crear issue con guía para ICF
        id: raise
        env:
          PLAN: ${{ inputs.plan }}
          DRY_RUN: ${{ inputs.dry_run }}
          ARTIFACT_DIR: ${{ needs.archive_export.outputs.artifact_dir }}
          METADATA_PATH: ${{ needs.archive_export.outputs.metadata_path }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          TARGET_MAP: '{"dev-to-qa":["qa"],"dev-qa-prod":["qa","prod"]}'
          TEMPLATE_PATH: .github/templates/icf-issue.md
          PROVISIONING_TEMPLATE_PATH: provisioning/icf-template.properties
          ICF_TEMPLATE_PATH: ${{ needs.archive_export.outputs.icf_template_path }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: python3 .github/scripts/create_icf_issue.py

  promote_qa:
    needs: [export, archive_export, icf_guidance]
    runs-on: ubuntu-latest
    environment: qa
    steps:
      - name: Validar artifact de export
        run: |
          if [ -z "$ARTIFACT_NAME" ]; then
            echo "❌ Export no entregó artifact_name; no se puede promover." >&2
            exit 1
          fi
        env:
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}

      - name: Descargar paquete
        id: download_package
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.export.outputs.artifact_name }}
          path: ${{ runner.temp }}/package

      - name: Determinar ruta del paquete
        id: package_path
        env:
          DOWNLOAD_DIR: ${{ steps.download_package.outputs.download-path }}
        run: |
          set -euo pipefail
          dir="${DOWNLOAD_DIR}"
          if [ -z "$dir" ]; then
            echo "No se pudo resolver la ruta de descarga del paquete." >&2
            exit 1
          fi
          pkg="$(find "$dir" -maxdepth 1 -type f -name '*.zip' | head -n 1)"
          if [ -z "$pkg" ]; then
            pkg="$(find "$dir" -maxdepth 1 -type f | head -n 1)"
          fi
          if [ -z "$pkg" ]; then
            echo "No se encontró el paquete exportado en $dir" >&2
            exit 1
          fi
          echo "package_path=$pkg" >> "$GITHUB_OUTPUT"

      - name: Construir ICF efímero
        id: build_icf
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-build-icf@icfbuild
        env:
          ICF_JSON_OVERRIDES: ${{ secrets.ICF_JSON_OVERRIDES }}
        with:
          template_path: provisioning/icf-template.properties
          env: qa
          out_path: ${{ runner.temp }}/icf-qa.properties

      - name: Promover paquete
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-promote@icfbuild
        with:
          source_env: dev
          target_env: qa
          package_path: ${{ steps.package_path.outputs.package_path }}
          icf_path: ${{ steps.build_icf.outputs.icf_path }}
          dry_run: ${{ inputs.dry_run }}
        env:
          APPIAN_API_KEY_TARGET: ${{ secrets.APPIAN_API_KEY_TARGET }}

      - name: Cleanup ICF
        if: ${{ always() }}
        run: shred -u ${{ steps.build_icf.outputs.icf_path }} || true

  promote_prod_after_qa:
    if: ${{ inputs.plan == 'dev-qa-prod' }}
    needs: [promote_qa, export]
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Validar artifact de export
        run: |
          if [ -z "$ARTIFACT_NAME" ]; then
            echo "❌ Export no entregó artifact_name; no se puede promover." >&2
            exit 1
          fi
        env:
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}

      - name: Descargar paquete
        id: download_package
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.export.outputs.artifact_name }}
          path: ${{ runner.temp }}/package

      - name: Determinar ruta del paquete
        id: package_path
        env:
          DOWNLOAD_DIR: ${{ steps.download_package.outputs.download-path }}
        run: |
          set -euo pipefail
          dir="${DOWNLOAD_DIR}"
          if [ -z "$dir" ]; then
            echo "No se pudo resolver la ruta de descarga del paquete." >&2
            exit 1
          fi
          pkg="$(find "$dir" -maxdepth 1 -type f -name '*.zip' | head -n 1)"
          if [ -z "$pkg" ]; then
            pkg="$(find "$dir" -maxdepth 1 -type f | head -n 1)"
          fi
          if [ -z "$pkg" ]; then
            echo "No se encontró el paquete exportado en $dir" >&2
            exit 1
          fi
          echo "package_path=$pkg" >> "$GITHUB_OUTPUT"

      - name: Construir ICF efímero
        id: build_icf
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-build-icf@icfbuild
        env:
          ICF_JSON_OVERRIDES: ${{ secrets.ICF_JSON_OVERRIDES }}
        with:
          template_path: provisioning/icf-template.properties
          env: prod
          out_path: ${{ runner.temp }}/icf-prod.properties

      - name: Promover paquete
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-promote@icfbuild
        with:
          source_env: dev
          target_env: prod
          package_path: ${{ steps.package_path.outputs.package_path }}
          icf_path: ${{ steps.build_icf.outputs.icf_path }}
          dry_run: ${{ inputs.dry_run }}
        env:
          APPIAN_API_KEY_TARGET: ${{ secrets.APPIAN_API_KEY_TARGET }}

      - name: Cleanup ICF
        if: ${{ always() }}
        run: shred -u ${{ steps.build_icf.outputs.icf_path }} || true
