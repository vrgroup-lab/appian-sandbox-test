name: Deploy App

on:
  workflow_dispatch:
    inputs:
      plan:
        description: Plan de promoción (sin dev-to-prod)
        type: choice
        options: [dev-to-qa, dev-qa-prod, qa-to-prod]
        default: dev-to-qa
      dry_run:
        description: Ejecutar promoción en modo dry-run
        type: choice
        options: ['false', 'true']
        default: 'false'

permissions:
  actions: write
  contents: write      # o write si lo necesitas
  pull-requests: write  # solo si el flujo crea PRs
  id-token: write
  issues: write 

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Validar inputs y variables
        run: |
          echo "plan=${{ inputs.plan }}"
          if [ -z "${{ vars.APP_UUID }}" ]; then
            echo "❌ Falta la variable de repositorio APP_UUID. Defínela en Settings > Secrets and variables > Variables." >&2
            exit 1
          fi
          if [ -z "${{ vars.APP_NAME }}" ]; then
            echo "❌ Falta la variable de repositorio APP_NAME. Defínela en Settings > Secrets and variables > Variables." >&2
            exit 1
          fi


  export:
    needs: validate
    uses: vrgroup-lab/appian-cicd-core/.github/workflows/export.yml@icfbuild
    secrets: inherit
    with:
      # Si el plan es qa-to-prod, exportamos desde QA; si no, desde Dev
      env: ${{ inputs.plan == 'qa-to-prod' && 'qa' || 'dev' }}
      deploy_kind: app
      app_uuid: ${{ vars.APP_UUID }}
      app_name: ${{ vars.APP_NAME || '' }}
      dry_run: false

  archive_export:
    name: Guardar artefactos de export
    needs: export
    runs-on: ubuntu-latest
    outputs:
      artifact_dir: ${{ steps.publish.outputs.artifact_dir }}
      metadata_path: ${{ steps.publish.outputs.metadata_path }}
    steps:
      - name: Checkout sandbox
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Preparar carpeta destino
        id: prep
        env:
          EXPORT_ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}
        run: |
          set -euo pipefail
          name="${EXPORT_ARTIFACT_NAME}"
          if [ -z "$name" ]; then
            name="export-${GITHUB_RUN_ID}"
          fi
          dest="appian-artifacts/$name"
          mkdir -p "$dest"
          echo "dest=$dest" >> "$GITHUB_OUTPUT"

      - name: Descargar paquete principal
        if: ${{ needs.export.outputs.artifact_name != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.export.outputs.artifact_name }}
          path: ${{ steps.prep.outputs.dest }}

      - name: Descargar metadata del export
        if: ${{ needs.export.outputs.artifact_name != '' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ format('{0}-meta', needs.export.outputs.artifact_name) }}
          path: ${{ steps.prep.outputs.dest }}

      - name: Registrar metadata de export
        env:
          DEST: ${{ steps.prep.outputs.dest }}
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}
          ARTIFACT_PATH: ${{ needs.export.outputs.artifact_path }}
          ARTIFACT_DIR: ${{ needs.export.outputs.artifact_dir }}
          MANIFEST_PATH: ${{ needs.export.outputs.manifest_path }}
          RAW_RESPONSE_PATH: ${{ needs.export.outputs.raw_response_path }}
          DEPLOYMENT_UUID: ${{ needs.export.outputs.deployment_uuid }}
          DEPLOYMENT_STATUS: ${{ needs.export.outputs.deployment_status }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json
          import os
          from pathlib import Path

          dest_dir = Path(os.environ["DEST"])
          metadata_path = dest_dir / "export-metadata.json"

          def resolved_path(output_value: str, fallback_name: str) -> str:
              if not output_value:
                  return str(dest_dir / fallback_name)
              candidate = Path(output_value)
              # Preserve basename but point inside DEST so that the metadata describes local copy
              return str(dest_dir / candidate.name)


          artifact_name = os.environ.get("ARTIFACT_NAME", "")
          artifact_path_output = os.environ.get("ARTIFACT_PATH", "")
          artifact_zip_name = Path(artifact_path_output).name if artifact_path_output else f"{artifact_name}.zip"

          data = {
              "artifact_name": artifact_name,
              "artifact_path": str(dest_dir / artifact_zip_name),
              "artifact_dir": str(dest_dir),
              "manifest_path": resolved_path(os.environ.get("MANIFEST_PATH", ""), "export-manifest.json"),
              "raw_response_path": resolved_path(os.environ.get("RAW_RESPONSE_PATH", ""), "export-response.json"),
              "deployment_uuid": os.environ.get("DEPLOYMENT_UUID", ""),
              "deployment_status": os.environ.get("DEPLOYMENT_STATUS", ""),
          }

          metadata_path.parent.mkdir(parents=True, exist_ok=True)
          metadata_path.write_text(json.dumps(data, indent=2), encoding="utf-8")
          PY

      - name: Publicar rutas generadas
        id: publish
        env:
          DEST: ${{ steps.prep.outputs.dest }}
        run: |
          set -euo pipefail
          echo "artifact_dir=${DEST}" >> "$GITHUB_OUTPUT"
          echo "metadata_path=${DEST}/export-metadata.json" >> "$GITHUB_OUTPUT"

      - name: Commit artefactos
        env:
          DEST: ${{ steps.prep.outputs.dest }}
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}
        run: |
          set -euo pipefail
          git status --short
          git add "$DEST"
          if git diff --cached --quiet; then
            echo "Sin cambios que versionar"
            exit 0
          fi
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git commit -m "chore: almacenar artefacto $ARTIFACT_NAME"
          git push

      - name: Mostrar detalles del deployment
        run: |
          echo "deployment_uuid=${{ needs.export.outputs.deployment_uuid }}"
          echo "deployment_status=${{ needs.export.outputs.deployment_status }}"

  icf_guidance:
    name: Registrar instrucciones ICF
    needs: archive_export
    runs-on: ubuntu-latest
    outputs:
      issue_number: ${{ steps.raise.outputs.issue_number }}
      issue_url: ${{ steps.raise.outputs.issue_url }}
    steps:
      - name: Crear issue con guía para ICF
        id: raise
        uses: actions/github-script@v7
        env:
          PLAN: ${{ inputs.plan }}
          DRY_RUN: ${{ inputs.dry_run }}
          ARTIFACT_DIR: ${{ needs.archive_export.outputs.artifact_dir }}
          METADATA_PATH: ${{ needs.archive_export.outputs.metadata_path }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const core = require('@actions/core');
            const plan = process.env.PLAN || 'desconocido';
            const dryRun = process.env.DRY_RUN || 'false';
            const artifactDir = process.env.ARTIFACT_DIR || '(sin directorio publicado)';
            const metadataPath = process.env.METADATA_PATH || '(sin metadata)';
            const runUrl = process.env.RUN_URL;

            const targetMap = {
              'dev-to-qa': ['qa'],
              'dev-qa-prod': ['qa', 'prod'],
              'qa-to-prod': ['prod']
            };
            const targets = targetMap[plan] || [];
            const targetsList = targets.length
              ? targets.map(env => `- \`${env}\``).join('\n')
              : '- _(no se identificó entorno de destino)_';

            const title = `[CI] Completar ICF_JSON_OVERRIDES – Run #${context.runNumber}`;
            core.info(`Preparando issue: ${title}`);

            const body = [
              '## ✅ Acción requerida',
              '',
              '1. Ve a **Settings → Secrets and variables → Actions → Repository secrets**.',
              '2. Edita el secreto `ICF_JSON_OVERRIDES` y agrega/actualiza las claves necesarias para esta promoción.',
              '3. Usa la plantilla `provisioning/icf-template.properties` como referencia para los valores obligatorios.',
              '4. Una vez actualizada la configuración, guarda el secreto y continúa con la aprobación en GitHub Actions.',
              '',
              '### Contexto de la ejecución',
              `- Plan seleccionado: \`${plan}\``,
              `- Dry run: \`${dryRun}\``,
              `- Directorio de artefacto: \`${artifactDir}\``,
              `- Metadata export: \`${metadataPath}\``,
              `- Ejecución: ${runUrl}`,
              '',
              '### Entornos objetivo detectados',
              targetsList,
              '',
              '> Cierra esta issue cuando los overrides estén listos. Si la promoción se repite, se generará una issue nueva.',
            ].join('\n');

            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            const existing = issues.find(issue => issue.title === title);
            if (existing) {
              core.info(`Issue ya existe (#${existing.number}).`);
              core.setOutput('issue_number', existing.number);
              core.setOutput('issue_url', existing.html_url);
              return;
            }

            const { data: created } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body
            });

            core.setOutput('issue_number', created.number);
            core.setOutput('issue_url', created.html_url);
            core.notice(`Issue creada: ${created.html_url}`);

  promote_qa:
    if: ${{ inputs.plan == 'dev-to-qa' || inputs.plan == 'dev-qa-prod' }}
    needs: [export, archive_export, icf_guidance]
    runs-on: ubuntu-latest
    environment: qa
    steps:
      - name: Validar artifact de export
        run: |
          if [ -z "$ARTIFACT_NAME" ]; then
            echo "❌ Export no entregó artifact_name; no se puede promover." >&2
            exit 1
          fi
        env:
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}

      - name: Descargar paquete/app
        id: download_package
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.export.outputs.artifact_name }}
          path: ${{ runner.temp }}/artifact

      - name: Determinar ruta del paquete/app
        id: package_path
        env:
          DOWNLOAD_DIR: ${{ steps.download_package.outputs.download-path }}
        run: |
          set -euo pipefail
          dir="${DOWNLOAD_DIR}"
          if [ -z "$dir" ]; then
            echo "No se pudo resolver la ruta de descarga del artefacto." >&2
            exit 1
          fi
          pkg="$(find "$dir" -maxdepth 1 -type f -name '*.zip' | head -n 1)"
          if [ -z "$pkg" ]; then
            pkg="$(find "$dir" -maxdepth 1 -type f | head -n 1)"
          fi
          if [ -z "$pkg" ]; then
            echo "No se encontró el artefacto exportado en $dir" >&2
            exit 1
          fi
          echo "package_path=$pkg" >> "$GITHUB_OUTPUT"

      - name: Construir ICF efímero
        id: build_icf
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-build-icf@icfbuild
        env:
          ICF_JSON_OVERRIDES: ${{ secrets.ICF_JSON_OVERRIDES }}
        with:
          template_path: provisioning/icf-template.properties
          env: qa
          out_path: ${{ runner.temp }}/icf-qa.properties

      - name: Promover aplicación
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-promote@icfbuild
        with:
          source_env: dev
          target_env: qa
          package_path: ${{ steps.package_path.outputs.package_path }}
          icf_path: ${{ steps.build_icf.outputs.icf_path }}
          dry_run: ${{ inputs.dry_run }}
        env:
          APPIAN_API_KEY_TARGET: ${{ secrets.APPIAN_API_KEY_TARGET }}

      - name: Cleanup ICF
        if: ${{ always() }}
        run: shred -u ${{ steps.build_icf.outputs.icf_path }} || true

  promote_prod_after_qa:
    if: ${{ inputs.plan == 'dev-qa-prod' }}
    needs: [promote_qa, export]
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Validar artifact de export
        run: |
          if [ -z "$ARTIFACT_NAME" ]; then
            echo "❌ Export no entregó artifact_name; no se puede promover." >&2
            exit 1
          fi
        env:
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}

      - name: Descargar paquete/app
        id: download_package
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.export.outputs.artifact_name }}
          path: ${{ runner.temp }}/artifact

      - name: Determinar ruta del paquete/app
        id: package_path
        env:
          DOWNLOAD_DIR: ${{ steps.download_package.outputs.download-path }}
        run: |
          set -euo pipefail
          dir="${DOWNLOAD_DIR}"
          if [ -z "$dir" ]; then
            echo "No se pudo resolver la ruta de descarga del artefacto." >&2
            exit 1
          fi
          pkg="$(find "$dir" -maxdepth 1 -type f -name '*.zip' | head -n 1)"
          if [ -z "$pkg" ]; then
            pkg="$(find "$dir" -maxdepth 1 -type f | head -n 1)"
          fi
          if [ -z "$pkg" ]; then
            echo "No se encontró el artefacto exportado en $dir" >&2
            exit 1
          fi
          echo "package_path=$pkg" >> "$GITHUB_OUTPUT"

      - name: Construir ICF efímero
        id: build_icf
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-build-icf@icfbuild
        env:
          ICF_JSON_OVERRIDES: ${{ secrets.ICF_JSON_OVERRIDES }}
        with:
          template_path: provisioning/icf-template.properties
          env: prod
          out_path: ${{ runner.temp }}/icf-prod.properties

      - name: Promover aplicación
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-promote@icfbuild
        with:
          source_env: dev
          target_env: prod
          package_path: ${{ steps.package_path.outputs.package_path }}
          icf_path: ${{ steps.build_icf.outputs.icf_path }}
          dry_run: ${{ inputs.dry_run }}
        env:
          APPIAN_API_KEY_TARGET: ${{ secrets.APPIAN_API_KEY_TARGET }}

      - name: Cleanup ICF
        if: ${{ always() }}
        run: shred -u ${{ steps.build_icf.outputs.icf_path }} || true

  promote_prod_from_qa:
    if: ${{ inputs.plan == 'qa-to-prod' }}
    needs: [export, archive_export, icf_guidance]
    runs-on: ubuntu-latest
    environment: prod
    steps:
      - name: Validar artifact de export
        run: |
          if [ -z "$ARTIFACT_NAME" ]; then
            echo "❌ Export no entregó artifact_name; no se puede promover." >&2
            exit 1
          fi
        env:
          ARTIFACT_NAME: ${{ needs.export.outputs.artifact_name }}

      - name: Descargar paquete/app
        id: download_package
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.export.outputs.artifact_name }}
          path: ${{ runner.temp }}/artifact

      - name: Determinar ruta del paquete/app
        id: package_path
        env:
          DOWNLOAD_DIR: ${{ steps.download_package.outputs.download-path }}
        run: |
          set -euo pipefail
          dir="${DOWNLOAD_DIR}"
          if [ -z "$dir" ]; then
            echo "No se pudo resolver la ruta de descarga del artefacto." >&2
            exit 1
          fi
          pkg="$(find "$dir" -maxdepth 1 -type f -name '*.zip' | head -n 1)"
          if [ -z "$pkg" ]; then
            pkg="$(find "$dir" -maxdepth 1 -type f | head -n 1)"
          fi
          if [ -z "$pkg" ]; then
            echo "No se encontró el artefacto exportado en $dir" >&2
            exit 1
          fi
          echo "package_path=$pkg" >> "$GITHUB_OUTPUT"

      - name: Construir ICF efímero
        id: build_icf
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-build-icf@icfbuild
        env:
          ICF_JSON_OVERRIDES: ${{ secrets.ICF_JSON_OVERRIDES }}
        with:
          template_path: provisioning/icf-template.properties
          env: prod
          out_path: ${{ runner.temp }}/icf-prod.properties

      - name: Promover aplicación
        uses: vrgroup-lab/appian-cicd-core/.github/actions/appian-promote@icfbuild
        with:
          source_env: qa
          target_env: prod
          package_path: ${{ steps.package_path.outputs.package_path }}
          icf_path: ${{ steps.build_icf.outputs.icf_path }}
          dry_run: ${{ inputs.dry_run }}
        env:
          APPIAN_API_KEY_TARGET: ${{ secrets.APPIAN_API_KEY_TARGET }}

      - name: Cleanup ICF
        if: ${{ always() }}
        run: shred -u ${{ steps.build_icf.outputs.icf_path }} || true
